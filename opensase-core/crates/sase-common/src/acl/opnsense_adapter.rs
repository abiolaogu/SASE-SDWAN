//! OPNsense Security Gateway Adapter (ACL)
//!
//! Translates between domain model and OPNsense/Suricata config.

use serde::{Deserialize, Serialize};

/// OPNsense adapter for security gateway integration
pub struct OpnSenseAdapter {
    api_url: String,
}

impl OpnSenseAdapter {
    pub fn new(api_url: &str) -> Self {
        Self {
            api_url: api_url.to_string(),
        }
    }

    /// Convert domain policy to nftables rules
    pub fn translate_to_nftables(
        &self,
        rules: &[FirewallRule],
    ) -> String {
        let mut output = String::new();
        output.push_str("#!/usr/sbin/nft -f\n");
        output.push_str("# Generated by OpenSASE - DO NOT EDIT\n\n");
        output.push_str("table inet opensase {\n");
        output.push_str("    chain forward {\n");
        output.push_str("        type filter hook forward priority 0; policy drop;\n\n");

        for rule in rules {
            output.push_str(&self.rule_to_nft(rule));
        }

        output.push_str("    }\n");
        output.push_str("}\n");
        output
    }

    fn rule_to_nft(&self, rule: &FirewallRule) -> String {
        let mut parts = Vec::new();

        if let Some(ref src) = rule.src_cidr {
            parts.push(format!("ip saddr {}", src));
        }
        if let Some(ref dst) = rule.dst_cidr {
            parts.push(format!("ip daddr {}", dst));
        }
        if let Some(port) = rule.dst_port {
            parts.push(format!("tcp dport {}", port));
        }

        let action = match rule.action.as_str() {
            "allow" => "accept",
            "deny" => "drop",
            "log" => "log accept",
            _ => "drop",
        };

        format!(
            "        # Rule {}: {}\n        {} {}\n\n",
            rule.id, rule.comment, parts.join(" "), action
        )
    }

    /// Convert to Suricata rules
    pub fn translate_to_suricata(
        &self,
        signatures: &[SuricataSignature],
    ) -> String {
        let mut output = String::new();
        output.push_str("# Generated by OpenSASE - DO NOT EDIT\n\n");

        for sig in signatures {
            output.push_str(&format!(
                "{} {} {} -> {} {} (msg:\"{}\"; sid:{}; rev:1; classtype:{};)\n",
                sig.action,
                sig.protocol,
                sig.src,
                sig.dst,
                sig.dst_port,
                sig.message,
                sig.sid,
                sig.classtype,
            ));
        }

        output
    }
}

/// Firewall rule for translation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FirewallRule {
    pub id: u32,
    pub src_cidr: Option<String>,
    pub dst_cidr: Option<String>,
    pub dst_port: Option<u16>,
    pub protocol: String,
    pub action: String,
    pub comment: String,
}

/// Suricata signature
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SuricataSignature {
    pub action: String,
    pub protocol: String,
    pub src: String,
    pub dst: String,
    pub dst_port: String,
    pub message: String,
    pub sid: u32,
    pub classtype: String,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_nftables_translation() {
        let adapter = OpnSenseAdapter::new("http://opnsense:8080");
        
        let rules = vec![
            FirewallRule {
                id: 1,
                src_cidr: Some("192.168.1.0/24".into()),
                dst_cidr: None,
                dst_port: Some(443),
                protocol: "tcp".into(),
                action: "allow".into(),
                comment: "Allow HTTPS from LAN".into(),
            },
        ];

        let nft = adapter.translate_to_nftables(&rules);
        assert!(nft.contains("ip saddr 192.168.1.0/24"));
        assert!(nft.contains("tcp dport 443"));
        assert!(nft.contains("accept"));
    }
}
