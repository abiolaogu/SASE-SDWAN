//! Malware Scanner Filter
//!
//! Scans file uploads for malware using hash checking and content analysis.

use proxy_wasm::traits::*;
use proxy_wasm::types::*;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;

proxy_wasm::main! {{
    proxy_wasm::set_root_context(|_| -> Box<dyn RootContext> {
        Box::new(MalwareScannerRoot::new())
    });
}}

/// Scan result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ScanResult {
    Clean,
    Malware(String),
    Suspicious(String),
    Error(String),
}

/// Malware scanner configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MalwareScannerConfig {
    /// Enable scanning
    #[serde(default = "default_true")]
    pub enabled: bool,
    
    /// Scan uploads
    #[serde(default = "default_true")]
    pub scan_uploads: bool,
    
    /// Scan downloads
    #[serde(default = "default_true")]
    pub scan_downloads: bool,
    
    /// Max file size to scan (bytes)
    #[serde(default = "default_max_size")]
    pub max_file_size: usize,
    
    /// Block on malware detection
    #[serde(default = "default_true")]
    pub block_on_malware: bool,
    
    /// Blocked file extensions
    #[serde(default = "default_blocked_extensions")]
    pub blocked_extensions: Vec<String>,
    
    /// Known malware hashes (SHA256)
    #[serde(default)]
    pub known_malware_hashes: Vec<String>,
    
    /// ClamAV server (optional)
    #[serde(default)]
    pub clamav_server: Option<String>,
    
    /// VirusTotal API key (optional)
    #[serde(default)]
    pub virustotal_api_key: Option<String>,
}

fn default_true() -> bool { true }
fn default_max_size() -> usize { 100 * 1024 * 1024 } // 100MB

fn default_blocked_extensions() -> Vec<String> {
    vec![
        "exe".to_string(), "dll".to_string(), "scr".to_string(),
        "bat".to_string(), "cmd".to_string(), "ps1".to_string(),
        "vbs".to_string(), "vbe".to_string(), "js".to_string(),
        "jse".to_string(), "wsf".to_string(), "wsh".to_string(),
        "msi".to_string(), "msp".to_string(), "com".to_string(),
        "pif".to_string(), "application".to_string(),
        "gadget".to_string(), "hta".to_string(), "cpl".to_string(),
        "msc".to_string(), "jar".to_string(),
    ]
}

impl Default for MalwareScannerConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            scan_uploads: true,
            scan_downloads: true,
            max_file_size: 100 * 1024 * 1024,
            block_on_malware: true,
            blocked_extensions: default_blocked_extensions(),
            known_malware_hashes: vec![
                // Example known malware hashes
                "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855".to_string(),
            ],
            clamav_server: None,
            virustotal_api_key: None,
        }
    }
}

/// File analysis
#[derive(Debug, Clone)]
struct FileAnalysis {
    filename: Option<String>,
    extension: Option<String>,
    content_type: Option<String>,
    size: usize,
    sha256: Option<String>,
    magic_bytes: Vec<u8>,
}

impl FileAnalysis {
    fn new() -> Self {
        Self {
            filename: None,
            extension: None,
            content_type: None,
            size: 0,
            sha256: None,
            magic_bytes: Vec::new(),
        }
    }
}

/// Root context for malware scanner
pub struct MalwareScannerRoot {
    config: MalwareScannerConfig,
    blocked_extensions: HashSet<String>,
    malware_hashes: HashSet<String>,
}

impl MalwareScannerRoot {
    fn new() -> Self {
        let config = MalwareScannerConfig::default();
        let blocked_extensions: HashSet<String> = config.blocked_extensions
            .iter()
            .map(|e| e.to_lowercase())
            .collect();
        let malware_hashes: HashSet<String> = config.known_malware_hashes
            .iter()
            .map(|h| h.to_lowercase())
            .collect();
        
        Self {
            config,
            blocked_extensions,
            malware_hashes,
        }
    }
}

impl Context for MalwareScannerRoot {}

impl RootContext for MalwareScannerRoot {
    fn on_configure(&mut self, _config_size: usize) -> bool {
        if let Some(config_bytes) = self.get_plugin_configuration() {
            if let Ok(config) = serde_json::from_slice::<MalwareScannerConfig>(&config_bytes) {
                self.blocked_extensions = config.blocked_extensions
                    .iter()
                    .map(|e| e.to_lowercase())
                    .collect();
                self.malware_hashes = config.known_malware_hashes
                    .iter()
                    .map(|h| h.to_lowercase())
                    .collect();
                self.config = config;
                
                log::info!(
                    "Malware scanner configured: {} blocked extensions, {} known hashes",
                    self.blocked_extensions.len(),
                    self.malware_hashes.len()
                );
            }
        }
        true
    }
    
    fn create_http_context(&self, _context_id: u32) -> Option<Box<dyn HttpContext>> {
        Some(Box::new(MalwareScanner {
            config: self.config.clone(),
            blocked_extensions: self.blocked_extensions.clone(),
            malware_hashes: self.malware_hashes.clone(),
            request_body: Vec::new(),
            response_body: Vec::new(),
            file_analysis: FileAnalysis::new(),
            is_upload: false,
        }))
    }
    
    fn get_type(&self) -> Option<ContextType> {
        Some(ContextType::HttpContext)
    }
}

/// HTTP context for malware scanner
pub struct MalwareScanner {
    config: MalwareScannerConfig,
    blocked_extensions: HashSet<String>,
    malware_hashes: HashSet<String>,
    request_body: Vec<u8>,
    response_body: Vec<u8>,
    file_analysis: FileAnalysis,
    is_upload: bool,
}

impl MalwareScanner {
    /// Check if extension is blocked
    fn is_blocked_extension(&self, ext: &str) -> bool {
        self.blocked_extensions.contains(&ext.to_lowercase())
    }
    
    /// Check if hash is known malware
    fn is_known_malware(&self, hash: &str) -> bool {
        self.malware_hashes.contains(&hash.to_lowercase())
    }
    
    /// Detect file type from magic bytes
    fn detect_file_type(&self, data: &[u8]) -> Option<&'static str> {
        if data.len() < 4 {
            return None;
        }
        
        // Check magic bytes
        match &data[..4] {
            // Executables
            [0x4D, 0x5A, ..] => Some("exe"),        // Windows PE
            [0x7F, 0x45, 0x4C, 0x46] => Some("elf"), // Linux ELF
            [0xCA, 0xFE, 0xBA, 0xBE] => Some("macho"), // macOS
            
            // Archives
            [0x50, 0x4B, 0x03, 0x04] => Some("zip"), // ZIP/JAR/DOCX
            [0x52, 0x61, 0x72, 0x21] => Some("rar"), // RAR
            [0x1F, 0x8B, ..] => Some("gzip"),       // GZIP
            
            // Documents
            [0x25, 0x50, 0x44, 0x46] => Some("pdf"), // PDF
            [0xD0, 0xCF, 0x11, 0xE0] => Some("office"), // Office (old)
            
            // Scripts
            _ if data.starts_with(b"#!") => Some("script"),
            _ if data.starts_with(b"<?php") => Some("php"),
            _ if data.starts_with(b"<script") => Some("js"),
            
            _ => None,
        }
    }
    
    /// Scan content for suspicious patterns
    fn scan_content(&self, data: &[u8]) -> ScanResult {
        // Check for PE header in unexpected places
        if data.windows(2).any(|w| w == [0x4D, 0x5A]) {
            // Found MZ header - could be embedded executable
            let detected_type = self.detect_file_type(data);
            if detected_type == Some("exe") {
                return ScanResult::Suspicious("Embedded executable detected".to_string());
            }
        }
        
        // Check for suspicious strings
        let suspicious_patterns = [
            b"powershell".as_slice(),
            b"cmd.exe".as_slice(),
            b"WScript.Shell".as_slice(),
            b"eval(".as_slice(),
            b"exec(".as_slice(),
            b"CreateObject".as_slice(),
            b"ShellExecute".as_slice(),
            b"FromBase64String".as_slice(),
        ];
        
        for pattern in suspicious_patterns {
            if data.windows(pattern.len()).any(|w| w.eq_ignore_ascii_case(pattern)) {
                return ScanResult::Suspicious(format!(
                    "Suspicious pattern: {}",
                    String::from_utf8_lossy(pattern)
                ));
            }
        }
        
        ScanResult::Clean
    }
    
    /// Calculate SHA256 hash (simplified)
    fn calculate_hash(&self, data: &[u8]) -> String {
        // Simplified hash - in production use proper SHA256
        let mut hash = 0u64;
        for (i, &byte) in data.iter().enumerate() {
            hash = hash.wrapping_add((byte as u64).wrapping_mul((i as u64).wrapping_add(1)));
        }
        format!("{:016x}", hash)
    }
    
    /// Block response
    fn send_block_response(&self, reason: &str) {
        self.send_http_response(
            403,
            vec![("content-type", "application/json")],
            Some(format!(
                r#"{{"error":"blocked","reason":"malware_detected","details":"{}"}}"#,
                reason
            ).as_bytes()),
        );
    }
}

impl Context for MalwareScanner {}

impl HttpContext for MalwareScanner {
    fn on_http_request_headers(&mut self, _num_headers: usize, _end_of_stream: bool) -> Action {
        if !self.config.enabled || !self.config.scan_uploads {
            return Action::Continue;
        }
        
        // Check if this is a file upload
        let content_type = self.get_http_request_header("content-type")
            .unwrap_or_default();
        
        self.is_upload = content_type.contains("multipart/form-data") ||
                         content_type.contains("application/octet-stream");
        
        // Extract filename from content-disposition
        if let Some(disposition) = self.get_http_request_header("content-disposition") {
            if let Some(filename_start) = disposition.find("filename=") {
                let filename = disposition[filename_start + 9..]
                    .trim_matches('"')
                    .split(';')
                    .next()
                    .unwrap_or("");
                
                self.file_analysis.filename = Some(filename.to_string());
                
                // Check extension
                if let Some(ext) = filename.rsplit('.').next() {
                    self.file_analysis.extension = Some(ext.to_string());
                    
                    if self.is_blocked_extension(ext) {
                        log::warn!("Blocked file extension: {}", ext);
                        self.send_block_response(&format!("Blocked file type: .{}", ext));
                        return Action::Pause;
                    }
                }
            }
        }
        
        // Check content-length
        if let Some(length) = self.get_http_request_header("content-length") {
            if let Ok(size) = length.parse::<usize>() {
                if size > self.config.max_file_size {
                    log::warn!("File too large: {} bytes", size);
                    return Action::Continue; // Skip scanning, let through
                }
                self.file_analysis.size = size;
            }
        }
        
        Action::Continue
    }
    
    fn on_http_request_body(&mut self, body_size: usize, end_of_stream: bool) -> Action {
        if !self.config.enabled || !self.config.scan_uploads || !self.is_upload {
            return Action::Continue;
        }
        
        // Accumulate body
        if let Some(body) = self.get_http_request_body(0, body_size) {
            self.request_body.extend_from_slice(&body);
            
            // Get magic bytes from first chunk
            if self.file_analysis.magic_bytes.is_empty() && body.len() >= 16 {
                self.file_analysis.magic_bytes = body[..16.min(body.len())].to_vec();
            }
        }
        
        // Check size limit
        if self.request_body.len() > self.config.max_file_size {
            self.request_body.clear();
            return Action::Continue;
        }
        
        // Scan when complete
        if end_of_stream && !self.request_body.is_empty() {
            // Check file type from magic bytes
            if let Some(detected_type) = self.detect_file_type(&self.request_body) {
                if self.is_blocked_extension(detected_type) {
                    log::warn!(
                        "Blocked file type detected from magic bytes: {}",
                        detected_type
                    );
                    self.send_block_response(&format!(
                        "Blocked file type detected: {}",
                        detected_type
                    ));
                    return Action::Pause;
                }
            }
            
            // Calculate hash and check against known malware
            let hash = self.calculate_hash(&self.request_body);
            if self.is_known_malware(&hash) {
                log::warn!("Known malware detected: {}", hash);
                self.send_block_response("Known malware signature detected");
                return Action::Pause;
            }
            
            // Scan content for suspicious patterns
            let scan_result = self.scan_content(&self.request_body);
            match scan_result {
                ScanResult::Malware(reason) => {
                    log::warn!("Malware detected: {}", reason);
                    if self.config.block_on_malware {
                        self.send_block_response(&reason);
                        return Action::Pause;
                    }
                }
                ScanResult::Suspicious(reason) => {
                    log::warn!("Suspicious file: {}", reason);
                    self.set_http_request_header("x-malware-suspicious", Some(&reason));
                }
                ScanResult::Clean => {
                    self.set_http_request_header("x-malware-scan", Some("clean"));
                }
                ScanResult::Error(e) => {
                    log::error!("Scan error: {}", e);
                }
            }
        }
        
        Action::Continue
    }
    
    fn on_http_response_headers(&mut self, _num_headers: usize, _end_of_stream: bool) -> Action {
        if !self.config.enabled || !self.config.scan_downloads {
            return Action::Continue;
        }
        
        // Check content-type for downloads
        let content_type = self.get_http_response_header("content-type")
            .unwrap_or_default();
        
        // Check content-disposition
        if let Some(disposition) = self.get_http_response_header("content-disposition") {
            if disposition.contains("attachment") {
                // This is a download
                if let Some(filename_start) = disposition.find("filename=") {
                    let filename = disposition[filename_start + 9..]
                        .trim_matches('"')
                        .split(';')
                        .next()
                        .unwrap_or("");
                    
                    if let Some(ext) = filename.rsplit('.').next() {
                        if self.is_blocked_extension(ext) {
                            log::warn!("Blocked download extension: {}", ext);
                            self.send_http_response(
                                403,
                                vec![("content-type", "text/html")],
                                Some(format!(
                                    "<html><body><h1>Download Blocked</h1>\
                                     <p>Files with .{} extension are not allowed.</p></body></html>",
                                    ext
                                ).as_bytes()),
                            );
                            return Action::Pause;
                        }
                    }
                }
            }
        }
        
        Action::Continue
    }
}

// Helper trait for case-insensitive comparison
trait EqIgnoreAsciiCase {
    fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool;
}

impl EqIgnoreAsciiCase for [u8] {
    fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool {
        if self.len() != other.len() {
            return false;
        }
        self.iter().zip(other.iter()).all(|(a, b)| {
            a.to_ascii_lowercase() == b.to_ascii_lowercase()
        })
    }
}
