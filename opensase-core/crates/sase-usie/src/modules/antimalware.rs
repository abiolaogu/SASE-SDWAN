//! Anti-Malware Module (lightweight)

use super::SecurityModule;
use crate::context::{InspectionContext, ModuleVerdict, VerdictAction, Severity};
use std::collections::HashSet;

/// AntiMalware Module
pub struct AntimalwareModule {
    known_bad_hashes: HashSet<[u8; 32]>,
    enabled: bool,
}

impl AntimalwareModule {
    pub fn new() -> Self {
        Self {
            known_bad_hashes: HashSet::new(),
            enabled: true,
        }
    }

    pub fn add_hash(&mut self, hash: [u8; 32]) {
        self.known_bad_hashes.insert(hash);
    }

    fn compute_sha256(data: &[u8]) -> [u8; 32] {
        // Simplified - in production use sha2 crate
        let mut hash = [0u8; 32];
        for (i, chunk) in data.chunks(32).enumerate() {
            for (j, &b) in chunk.iter().enumerate() {
                hash[(i + j) % 32] ^= b;
            }
        }
        hash
    }
}

impl Default for AntimalwareModule {
    fn default() -> Self { Self::new() }
}

impl SecurityModule for AntimalwareModule {
    fn name(&self) -> &'static str { "antimalware" }
    fn is_enabled(&self) -> bool { self.enabled }

    fn inspect(&self, ctx: &InspectionContext) -> Option<ModuleVerdict> {
        let payload = ctx.payload.as_bytes();
        if payload.len() < 100 { return None; }

        let hash = Self::compute_sha256(payload);
        if self.known_bad_hashes.contains(&hash) {
            return Some(ModuleVerdict {
                module: self.name(),
                action: VerdictAction::Block,
                reason: "Known malware hash detected".into(),
                rule_id: None,
                severity: Severity::Critical,
            });
        }
        None
    }
}
